using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Security.Cryptography;


namespace UnityTwine.Editor
{
    public static class TweeParser
    {
		static Regex rx_Passages = new Regex(@"^::\s(?<id>[a-zA-Z0-9_]+)(\s*\[(?<tags>[^\n]+)\])?\n(?<content>.*?)(?=\n::|\Z)",
            RegexOptions.Singleline | RegexOptions.Multiline | RegexOptions.ExplicitCapture);

		static Regex rx_Tags = new Regex(@"\b(?<key>[a-zA-Z_][a-zA-Z0-9_]*)(:(?<value>[^\s]*))?", RegexOptions.ExplicitCapture);

        static Regex rx_String;
        static Regex rx_IfElse;
        static Regex rx_Vars;
        static Regex rx_Operator;
        static Regex rx_Setter;
        static Regex rx_Link;
        static Regex rx_Display;

		static MD5 _md5 = MD5.Create();

		class PassageData
		{
			public string PassageID;
			public string Tags;
			public string Code;
		}

        static TweeParser()
        {
            rx_String = new Regex(
				@"(?!(<<|\[\[))(?<=(>>|\]\]|^))(?<bol>^)?(?<text>.*?)(?<eol>$)?(?=(<<|\[\[|$))(?!(>>|\]\]))",
                //"yield return @\"${text}\";",
				RegexOptions.Singleline |RegexOptions.Multiline|RegexOptions.ExplicitCapture
            );
            rx_IfElse = new Regex(
				@"(?:<<\s*(?<construct>if|elseif|else|endif)\b\s*(?<condition>.*?)>>)",
                //"if ($1) {",
                RegexOptions.Singleline|RegexOptions.Multiline|RegexOptions.ExplicitCapture
            );
            rx_Vars = new Regex(
                @"\$([a-zA-Z_][a-zA-Z0-9_]*)",
                //var$2[“$1”],
                RegexOptions.Singleline|RegexOptions.Multiline
            );
            rx_Operator = new Regex(
                @"\b(and|or|is|to|not)\b(?=([^""]*""[^""]*"")*[^""]*$)",
                //"OPERATOR",
                RegexOptions.Singleline|RegexOptions.Multiline
            );
            rx_Setter = new Regex(
                @"<<\s*set\s+(.*?)\s*>>",
                //"$1",
                RegexOptions.Singleline|RegexOptions.Multiline
            );
            rx_Link  = new Regex(
				@"\[\[(?:(?:(?<name>[^|]+?)\s*=\s*)?(?<text>.*?)\|)?(?<passage>.+?)\](?:\[(?<setters>.*?)\])?\]",
                RegexOptions.Singleline|RegexOptions.Multiline|RegexOptions.ExplicitCapture
            );
			
			// TODO: shorthand code with parameters
            rx_Display = new Regex(
                @"<<\s*display\s*(.*?)\s*>>",
                //"yield return new TwineSubPassage(\"$1\");",
                RegexOptions.Singleline|RegexOptions.Multiline
            );
        }

        public static void ParseToStream(string name, string tweeSource, StreamWriter output)
        {
			string[] vars;
			PassageData[] passages = ParseFile(tweeSource, out vars);

            output.Write(
@"/*
Generated by UnityTwine on {0}
https://github.com/daterre/UnityTwine
*/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityTwine;

public class {1}: TwineStory
{{"
			, DateTime.Now.ToString("G"), name);

			for (int i = 0; i < vars.Length; i++)
				output.Write(@"
	public TwineVar {0};", vars[i]);

			output.Write(@"
	public override TwineVar this[string name]
	{
		get
		{
			switch(name)
			{"
			);
			for (int i = 0; i < vars.Length; i++)
				output.Write(@"
				case ""{0}"": return {0};", vars[i]);

			output.Write(@"
				default: throw new KeyNotFoundException(string.Format(""There is no variable with the name '{0}'."", name));
			}
		}
		set
		{
			switch(name)
			{"
			);
			for (int i = 0; i < vars.Length; i++)
				output.Write(@"
				case ""{0}"": {0} = value; break;", vars[i]);

			output.Write(@"
				default: throw new KeyNotFoundException(string.Format(""There is no variable with the name '{0}'."", name));
			}
		}
	}
");

			output.Write(@"

	void Awake() {
		base.Init();"
			);
            for (int i = 0; i < passages.Length; i++)
                output.Write(@"
		passageInit_{0}();"
                    , i); 

    		output.Write(@"
	}");

			for (int i = 0; i < passages.Length; i++)
			{
				PassageData passage = passages[i];
				output.Write(@"
    
	// .............
	// #{0}: {1}

	void passageInit_{0}()
	{{
		this.Passages[""{1}""] = new TwinePassage(""{1}"", new Dictionary<string,string>(){{ {2} }}, passageExecute_{0});
	}}

	IEnumerable<TwineOutput> passageExecute_{0}()
	{{
		{3}	
	}}"
				, i, passage.PassageID, passage.Tags, passage.Code.Replace("\n", "\n\t\t"));
			}

			output.Write(@"

}"
				);
		}
			

		static PassageData[] ParseFile(string tweeSource, out string[] vars)
        {
            MatchCollection matches = rx_Passages.Matches(tweeSource);
			var passages = new PassageData[matches.Count];
			var varNames = new Dictionary<string,string>();

            for (int i = 0; i < matches.Count; i++)
            {
                Match m = matches[i];

				passages[i] = new PassageData() {
					PassageID = m.Groups["id"].Value,
					Tags = ParseTags(m.Groups["tags"].Value),
					Code = ParseContent(m.Groups["content"].Value.Trim(), varNames)
				};

				if (passages[i].Code == null || passages[i].Code.Trim().Length == 0)
					passages[i].Code = "yield break;";
            }

			vars = varNames.Keys.ToArray();
            return passages;
        }

		static string ParseTags(string tweeTags)
        {
			return rx_Tags.Replace(tweeTags, "{\"${key}\", \"${value}\"},");
        }

		static string ParseContent(string tweeCode, Dictionary<string,string> vars)
        {
            string output = tweeCode;

            // Regular text
            output = rx_String.Replace(output, match=>{
                string value = match.Groups["text"].Value;
				bool bol = match.Groups["bol"].Success; // beginning of line
				bool eol = match.Groups["eol"].Success; // end of line
                return
					(bol && eol) || value.Trim().Length > 0 ? 
                   
					// output the string, even empty if its a single line
					String.Format("yield return new TwineText(@\"{0}\");", value
						.Replace("\"", "\"\"")
						.Replace("\n", "\\n")
					) :

					// only beginning or end of line is whitespace, use it as C# whitespace
					value
                ;
            });

            // <<if ... >>
            output = rx_IfElse.Replace(output, match => {

                string construct = match.Groups["construct"].Value;
                string statement;

                switch(construct) {
                    case "else" : return "} else { ";
                    case "endif" : return "} ";
                    case "if" : statement = "if ({0}) {{ "; break;
                    case "elseif": statement = "}} else if ({0}) {{ "; break;
                    default: throw new Exception("Invalid construct " + construct);
                }

                string condition = ParseVars(match.Groups["condition"].Value, vars);
                condition = rx_Operator.Replace(condition, op => {
                    switch (op.Value) {
                        case "and": return "&&" ;
                        case "or" : return "||";
                        case "is" : return "==";
                        case "to" : return "=";
                        case "not" : return "!";
                    };
					return string.Empty;
                });

                return String.Format(statement, condition);
            });

            // <<set ... >>
            output = rx_Setter.Replace(output, match => string.Format("{0};", ParseVars(match.Groups[1].Value, vars)));

            // [[kiss = Kiss the girl|scene1_kiss][$girl = 'kissed';]]
            output = rx_Link.Replace(output, match => {
				string passage = match.Groups["passage"].Value;
				string text = match.Groups["text"].Success ? match.Groups["text"].Value : passage;
				string name = match.Groups["name"].Success ? match.Groups["name"].Value : text;
                string setters = match.Groups["setters"].Length > 0 ?
					string.Format("() =>{{ {0}; }}", ParseVars(match.Groups["setters"].Value, vars)) : // stick the setter into a lambda
                    null;
				string settersHash = setters == null ? null : Convert.ToBase64String(_md5.ComputeHash(Encoding.UTF8.GetBytes(setters)));
				return string.Format("yield return new TwineLink(@\"{0}\", @\"{1}\", {2}, {3}, {4});",
					name.Replace("\"", "\"\""),
					text.Replace("\"", "\"\""),
					passage.IndexOf('(') >= 1 ? passage : string.Format("@\"{0}\"", passage.Replace("\"", "\"\"")), // if a peren is present, treat as a function
					setters == null ? "null" : setters,
					setters == null ? "null" : '"' + settersHash + '"'
				);
            });

            // <<display ... >
			output = rx_Display.Replace(output, match =>
				string.Format("yield return new TwineDisplay({0});", ParseVars(match.Groups[1].Value, vars))
			);

            return output;
        }

		static string ParseVars(string expression, Dictionary<string, string> vars)
		{
			return rx_Vars.Replace(expression, varName =>
			{
				string val = varName.Groups[1].Value;
				vars[val] = null;
				return val;
			});
		}
            
    }
}
